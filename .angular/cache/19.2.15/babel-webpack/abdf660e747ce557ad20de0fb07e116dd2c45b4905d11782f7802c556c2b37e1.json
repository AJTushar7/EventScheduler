{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class CalendarSchedulerService {\n  constructor() {\n    this.eventsSubject = new BehaviorSubject([]);\n    this.selectedExecutionTimeSubject = new BehaviorSubject('11:00');\n    this.conflictSubject = new BehaviorSubject({\n      hasConflict: false\n    });\n    this.events$ = this.eventsSubject.asObservable();\n    this.selectedExecutionTime$ = this.selectedExecutionTimeSubject.asObservable();\n    this.conflict$ = this.conflictSubject.asObservable();\n    this.executionDuration = 60; // minutes (1 hour)\n    this.loadExistingEvents();\n  }\n  loadExistingEvents() {\n    const events = [{\n      id: '1',\n      startTime: '11:33',\n      endTime: '12:33',\n      type: 'booked'\n    }, {\n      id: '2',\n      startTime: '14:07',\n      endTime: '15:07',\n      type: 'booked'\n    }, {\n      id: '3',\n      startTime: '18:30',\n      endTime: '19:30',\n      type: 'booked'\n    }];\n    this.eventsSubject.next(events);\n  }\n  timeToMinutes(time) {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + minutes;\n  }\n  minutesToTime(minutes) {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;\n  }\n  getTimePosition(startTime, endTime) {\n    const startMinutes = this.timeToMinutes(startTime);\n    const endMinutes = this.timeToMinutes(endTime);\n    const gridStartMinutes = 9 * 60; // 9:00 AM (540 minutes)\n    const totalSlots = 12; // We have 12 time slot columns\n    // Calculate which slot the start and end times fall into\n    const relativeStartMinutes = startMinutes - gridStartMinutes;\n    const relativeEndMinutes = endMinutes - gridStartMinutes;\n    // Convert to slot positions (each slot = 60 minutes)\n    const startSlotPosition = relativeStartMinutes / 60; // Position in hours from 9:00\n    const endSlotPosition = relativeEndMinutes / 60; // Position in hours from 9:00\n    // Calculate percentage positions\n    const leftPercent = startSlotPosition / totalSlots * 100;\n    const widthPercent = (endSlotPosition - startSlotPosition) / totalSlots * 100;\n    // Ensure bounds are within the grid\n    const finalLeft = Math.max(0, Math.min(leftPercent, 100));\n    const finalWidth = Math.max(0, Math.min(widthPercent, 100 - finalLeft));\n    console.log(`Positioning ${startTime}-${endTime}: left=${finalLeft.toFixed(2)}%, width=${finalWidth.toFixed(2)}%`);\n    return {\n      left: `${finalLeft.toFixed(2)}%`,\n      width: `${finalWidth.toFixed(2)}%`\n    };\n  }\n  checkForConflicts(executionTime) {\n    const selectedTime = executionTime || this.selectedExecutionTimeSubject.value;\n    const selectedMinutes = this.timeToMinutes(selectedTime);\n    const endMinutes = selectedMinutes + this.executionDuration;\n    const endTime = this.minutesToTime(endMinutes);\n    console.log(`Checking conflict for: ${selectedTime} to ${endTime}`);\n    const events = this.eventsSubject.value;\n    let conflictInfo = {\n      hasConflict: false\n    };\n    for (const event of events) {\n      if (event.type === 'booked') {\n        console.log(`Existing event: ${event.startTime} to ${event.endTime}`);\n        const eventStartMinutes = this.timeToMinutes(event.startTime);\n        const eventEndMinutes = this.timeToMinutes(event.endTime);\n        console.log(`New event minutes: ${selectedMinutes} to ${endMinutes}`);\n        console.log(`Existing event minutes: ${eventStartMinutes} to ${eventEndMinutes}`);\n        const hasOverlap = selectedMinutes < eventEndMinutes && endMinutes > eventStartMinutes;\n        console.log(`Overlap check: ${selectedMinutes} < ${eventEndMinutes} && ${endMinutes} > ${eventStartMinutes} = ${hasOverlap}`);\n        if (hasOverlap) {\n          console.log('Conflict detected with:', event);\n          conflictInfo = {\n            hasConflict: true,\n            conflictingEvent: event,\n            message: `Your selected time (${selectedTime} - ${endTime}) conflicts with an existing event (${event.startTime} - ${event.endTime}).`\n          };\n          break;\n        }\n      }\n    }\n    this.conflictSubject.next(conflictInfo);\n  }\n  updateExecutionTime(time) {\n    this.selectedExecutionTimeSubject.next(time);\n    this.checkForConflicts(time);\n  }\n  getNewEventPreview() {\n    const selectedTime = this.selectedExecutionTimeSubject.value;\n    const selectedMinutes = this.timeToMinutes(selectedTime);\n    const endMinutes = selectedMinutes + this.executionDuration;\n    const endTime = this.minutesToTime(endMinutes);\n    return {\n      id: 'preview',\n      startTime: selectedTime,\n      endTime: endTime,\n      type: 'new'\n    };\n  }\n  confirmExecution() {\n    const conflict = this.conflictSubject.value;\n    if (!conflict.hasConflict) {\n      const newEvent = this.getNewEventPreview();\n      if (newEvent) {\n        const currentEvents = this.eventsSubject.value;\n        const updatedEvents = [...currentEvents, {\n          ...newEvent,\n          id: Date.now().toString()\n        }];\n        this.eventsSubject.next(updatedEvents);\n        console.log('Event confirmed and added to calendar');\n      }\n    }\n  }\n  getAvailableTimeSlots() {\n    return ['09:00', '09:15', '09:30', '09:45', '10:00', '10:15', '10:30', '10:45', '11:00', '11:15', '11:30', '11:33', '11:45', '12:00', '12:15', '12:30', '12:33', '12:45', '12:47', '13:00', '13:15', '13:30', '13:45', '14:00', '14:07', '14:15', '14:30', '14:45', '15:00', '15:07', '15:15', '15:30', '15:45', '16:00', '16:15', '16:30', '16:45', '17:00', '17:15', '17:30', '17:45', '18:00', '18:15', '18:30', '18:45', '19:00', '19:15', '19:30', '19:45', '20:00'];\n  }\n  getTimeSlotHeaders() {\n    return [{\n      hour: 9,\n      label: '9:00'\n    }, {\n      hour: 10,\n      label: '10:00'\n    }, {\n      hour: 11,\n      label: '11:00'\n    }, {\n      hour: 12,\n      label: '12:00'\n    }, {\n      hour: 13,\n      label: '13:00'\n    }, {\n      hour: 14,\n      label: '14:00'\n    }, {\n      hour: 15,\n      label: '15:00'\n    }, {\n      hour: 16,\n      label: '16:00'\n    }, {\n      hour: 17,\n      label: '17:00'\n    }, {\n      hour: 18,\n      label: '18:00'\n    }, {\n      hour: 19,\n      label: '19:00'\n    }, {\n      hour: 20,\n      label: '20:00'\n    }];\n  }\n  static {\n    this.ɵfac = function CalendarSchedulerService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CalendarSchedulerService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: CalendarSchedulerService,\n      factory: CalendarSchedulerService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","CalendarSchedulerService","constructor","eventsSubject","selectedExecutionTimeSubject","conflictSubject","hasConflict","events$","asObservable","selectedExecutionTime$","conflict$","executionDuration","loadExistingEvents","events","id","startTime","endTime","type","next","timeToMinutes","time","hours","minutes","split","map","Number","minutesToTime","Math","floor","mins","toString","padStart","getTimePosition","startMinutes","endMinutes","gridStartMinutes","totalSlots","relativeStartMinutes","relativeEndMinutes","startSlotPosition","endSlotPosition","leftPercent","widthPercent","finalLeft","max","min","finalWidth","console","log","toFixed","left","width","checkForConflicts","executionTime","selectedTime","value","selectedMinutes","conflictInfo","event","eventStartMinutes","eventEndMinutes","hasOverlap","conflictingEvent","message","updateExecutionTime","getNewEventPreview","confirmExecution","conflict","newEvent","currentEvents","updatedEvents","Date","now","getAvailableTimeSlots","getTimeSlotHeaders","hour","label","factory","ɵfac","providedIn"],"sources":["/home/runner/workspace/src/app/services/calendar-scheduler.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nexport interface CalendarEvent {\n  id: string;\n  startTime: string;\n  endTime: string;\n  type: 'booked' | 'new';\n}\n\nexport interface EventPosition {\n  left: string;\n  width: string;\n}\n\nexport interface ConflictInfo {\n  hasConflict: boolean;\n  conflictingEvent?: CalendarEvent;\n  message?: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CalendarSchedulerService {\n  private eventsSubject = new BehaviorSubject<CalendarEvent[]>([]);\n  private selectedExecutionTimeSubject = new BehaviorSubject<string>('11:00');\n  private conflictSubject = new BehaviorSubject<ConflictInfo>({ hasConflict: false });\n\n  public events$ = this.eventsSubject.asObservable();\n  public selectedExecutionTime$ = this.selectedExecutionTimeSubject.asObservable();\n  public conflict$ = this.conflictSubject.asObservable();\n\n  private executionDuration = 60; // minutes (1 hour)\n\n  constructor() {\n    this.loadExistingEvents();\n  }\n\n  private loadExistingEvents(): void {\n    const events: CalendarEvent[] = [\n      {\n        id: '1',\n        startTime: '11:33',\n        endTime: '12:33',\n        type: 'booked'\n      },\n      {\n        id: '2', \n        startTime: '14:07',\n        endTime: '15:07',\n        type: 'booked'\n      },\n      {\n        id: '3',\n        startTime: '18:30',\n        endTime: '19:30',\n        type: 'booked'\n      }\n    ];\n    this.eventsSubject.next(events);\n  }\n\n  timeToMinutes(time: string): number {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + minutes;\n  }\n\n  minutesToTime(minutes: number): string {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;\n  }\n\n  getTimePosition(startTime: string, endTime: string): EventPosition {\n    const startMinutes = this.timeToMinutes(startTime);\n    const endMinutes = this.timeToMinutes(endTime);\n    \n    const gridStartMinutes = 9 * 60; // 9:00 AM (540 minutes)\n    const totalSlots = 12; // We have 12 time slot columns\n    \n    // Calculate which slot the start and end times fall into\n    const relativeStartMinutes = startMinutes - gridStartMinutes;\n    const relativeEndMinutes = endMinutes - gridStartMinutes;\n    \n    // Convert to slot positions (each slot = 60 minutes)\n    const startSlotPosition = relativeStartMinutes / 60; // Position in hours from 9:00\n    const endSlotPosition = relativeEndMinutes / 60; // Position in hours from 9:00\n    \n    // Calculate percentage positions\n    const leftPercent = (startSlotPosition / totalSlots) * 100;\n    const widthPercent = ((endSlotPosition - startSlotPosition) / totalSlots) * 100;\n    \n    // Ensure bounds are within the grid\n    const finalLeft = Math.max(0, Math.min(leftPercent, 100));\n    const finalWidth = Math.max(0, Math.min(widthPercent, 100 - finalLeft));\n    \n    console.log(`Positioning ${startTime}-${endTime}: left=${finalLeft.toFixed(2)}%, width=${finalWidth.toFixed(2)}%`);\n    \n    return {\n      left: `${finalLeft.toFixed(2)}%`,\n      width: `${finalWidth.toFixed(2)}%`\n    };\n  }\n\n  checkForConflicts(executionTime?: string): void {\n    const selectedTime = executionTime || this.selectedExecutionTimeSubject.value;\n    const selectedMinutes = this.timeToMinutes(selectedTime);\n    const endMinutes = selectedMinutes + this.executionDuration;\n    const endTime = this.minutesToTime(endMinutes);\n    \n    console.log(`Checking conflict for: ${selectedTime} to ${endTime}`);\n    \n    const events = this.eventsSubject.value;\n    let conflictInfo: ConflictInfo = { hasConflict: false };\n    \n    for (const event of events) {\n      if (event.type === 'booked') {\n        console.log(`Existing event: ${event.startTime} to ${event.endTime}`);\n        \n        const eventStartMinutes = this.timeToMinutes(event.startTime);\n        const eventEndMinutes = this.timeToMinutes(event.endTime);\n        \n        console.log(`New event minutes: ${selectedMinutes} to ${endMinutes}`);\n        console.log(`Existing event minutes: ${eventStartMinutes} to ${eventEndMinutes}`);\n        \n        const hasOverlap = selectedMinutes < eventEndMinutes && endMinutes > eventStartMinutes;\n        console.log(`Overlap check: ${selectedMinutes} < ${eventEndMinutes} && ${endMinutes} > ${eventStartMinutes} = ${hasOverlap}`);\n        \n        if (hasOverlap) {\n          console.log('Conflict detected with:', event);\n          conflictInfo = {\n            hasConflict: true,\n            conflictingEvent: event,\n            message: `Your selected time (${selectedTime} - ${endTime}) conflicts with an existing event (${event.startTime} - ${event.endTime}).`\n          };\n          break;\n        }\n      }\n    }\n    \n    this.conflictSubject.next(conflictInfo);\n  }\n\n  updateExecutionTime(time: string): void {\n    this.selectedExecutionTimeSubject.next(time);\n    this.checkForConflicts(time);\n  }\n\n  getNewEventPreview(): CalendarEvent | null {\n    const selectedTime = this.selectedExecutionTimeSubject.value;\n    const selectedMinutes = this.timeToMinutes(selectedTime);\n    const endMinutes = selectedMinutes + this.executionDuration;\n    const endTime = this.minutesToTime(endMinutes);\n    \n    return {\n      id: 'preview',\n      startTime: selectedTime,\n      endTime: endTime,\n      type: 'new'\n    };\n  }\n\n  confirmExecution(): void {\n    const conflict = this.conflictSubject.value;\n    if (!conflict.hasConflict) {\n      const newEvent = this.getNewEventPreview();\n      if (newEvent) {\n        const currentEvents = this.eventsSubject.value;\n        const updatedEvents = [...currentEvents, { ...newEvent, id: Date.now().toString() }];\n        this.eventsSubject.next(updatedEvents);\n        console.log('Event confirmed and added to calendar');\n      }\n    }\n  }\n\n  getAvailableTimeSlots(): string[] {\n    return [\n      '09:00', '09:15', '09:30', '09:45',\n      '10:00', '10:15', '10:30', '10:45',\n      '11:00', '11:15', '11:30', '11:33', '11:45',\n      '12:00', '12:15', '12:30', '12:33', '12:45', '12:47',\n      '13:00', '13:15', '13:30', '13:45',\n      '14:00', '14:07', '14:15', '14:30', '14:45',\n      '15:00', '15:07', '15:15', '15:30', '15:45',\n      '16:00', '16:15', '16:30', '16:45',\n      '17:00', '17:15', '17:30', '17:45',\n      '18:00', '18:15', '18:30', '18:45',\n      '19:00', '19:15', '19:30', '19:45',\n      '20:00'\n    ];\n  }\n\n  getTimeSlotHeaders(): { hour: number; label: string }[] {\n    return [\n      { hour: 9, label: '9:00' },\n      { hour: 10, label: '10:00' },\n      { hour: 11, label: '11:00' },\n      { hour: 12, label: '12:00' },\n      { hour: 13, label: '13:00' },\n      { hour: 14, label: '14:00' },\n      { hour: 15, label: '15:00' },\n      { hour: 16, label: '16:00' },\n      { hour: 17, label: '17:00' },\n      { hour: 18, label: '18:00' },\n      { hour: 19, label: '19:00' },\n      { hour: 20, label: '20:00' }\n    ];\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}